<!DOCTYPE html>

<div id="page" class="hfeed site">
		<header id="masthead" class="site-header clearfix"><div id="header-text-nav-container" class="clearfix">
			<div class="inner-wrap">
				<div id="header-text-nav-wrap" class="clearfix">
					<div id="header-left-section">
												<div id="header-text" class="">
															<h3 id="site-title">
									<a href="https://software-engineering-book.com/" title="Software Engineering 10th edition" rel="home">Software Engineering 10th edition</a>
								</h3>
															<h3 id="site-description">Web sections</h3>
													</div>
					</div>
			</div>

	</div>

		
	</header><div id="main" class="clearfix">
		<div class="inner-wrap clearfix">


	<div id="primary">
		<div id="content" class="clearfix">
						
<article id="post-692" class="post-692 page type-page status-publish hentry"><header class="entry-header"><h1 class="entry-title">
				Centralized control			</h1>
			</header><div class="entry-content clearfix">
		<p>In a centralized control model, one component is designated as the controller and is responsible for managing the execution of other components. Centralized control models fall into two classes, depending on whether the controlled components execute sequentially or in parallel.</p>
<ol><li><em>The call–return model</em> This is the familiar top-down subroutine model where control starts at the top of a subroutine hierarchy and, through subroutine calls, passes to lower levels in the tree. The subroutine model is only applicable to sequential systems.</li>
<li><em>The manager model </em>This is applicable to concurrent systems. One system component is designated as a system manager and controls the starting, stopping, coordination and scheduling of other system processes. A process is a component or module that can execute in parallel with other processes. A form of this model may also be applied in sequential systems where a management routine calls particular components depending on the values of some state variables. This is usually implemented as a case statement.</li>
</ol><p>The call–return model is illustrated in the following diagram. The main program can call Routines 1, 2 and 3; Routine 1 can call Routines 1.2 or 1.2; Routine 3 can call Routines 3.1 or 3.2; and so on. This is a model of the program dynamics. It is not a structural model; there is no need for Routine 1.1, for example, to be part of Routine 1.</p>
<img class="myimg horiz" src="https://www.dropbox.com/s/7aiurj6p2rxwif6/11.7%20CallReturn.jpg?raw=1" alt="Image"></noscript><figcaption class="mycap">
A call-return control model<br></figcaption></figure><p>This familiar model is embedded in programming languages such as C, Ada and Pascal. Control passes from a higher-level routine in the hierarchy to a lower-level routine. It then returns to the point where the routine was called. The currently executing subroutine has responsibility for control and can either call other routines or return control to its parent. It is poor programming style to return to some other point in the program.</p>
<p>This call–return model may be used at the module level to control functions or objects. Subroutines in a programming language that are called by other subroutines are naturally functional. However, in many object-oriented systems, operations on objects (methods) are implemented as procedures or functions. For example, when a Java object requests a service from another object, it does so by calling an associated method.</p>
<p>The rigid and restricted nature of this model is both a strength and a weakness. It is a strength because it is relatively simple to analyse control flows and work out how the system will respond to particular inputs. It is a weakness because exceptions to normal operation are awkward to handle.</p>
<p>The diagram below is an illustration of a centralised management model of control for a concurrent system. This model is often used in ‘soft’ real-time systems which do not have very tight time constraints. The central controller manages the execution of a set of processes associated with sensors and actuators. The building monitoring system discussed in Chapter 21 uses this model of control.</p>
<img class="myimg horiz" src="https://www.dropbox.com/s/s1oe2y6l96aflyw/11.8%20CentralisedControl.jpg?raw=1" alt="Image"></noscript><figcaption class="mycap">
A centralized control model for a real-time system<br></figcaption></figure><p>The system controller process decides when processes should be started or stopped depending on system state variables. It checks if other processes have produced information to be processed or to pass information to them for processing. The controller loops continuously, polling sensors and other processes for events or state changes. For this reason, this model is sometimes called an event-loop model.</p>
			</div>

	</article></div>
	</div>




		</div>
	</div>
			<footer id="colophon" class="clearfix"><div class="footer-socket-wrapper clearfix">
				<div class="inner-wrap">
					<div class="footer-socket-area">
						<div class="copyright">Copyright © 2019&nbsp<a href="https://software-engineering-book.com/" title="Software Engineering 10th edition"><span>Software Engineering 10th edition</span></a>. </div>					</div>
				</div>
			</div>
		</footer><a href="#masthead" id="scroll-up"><i class="fa fa-chevron-up"></i></a>
	</div>
		<div style="display:none">
	</div>
